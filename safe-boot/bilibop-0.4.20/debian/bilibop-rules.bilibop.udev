# /lib/udev/rules.d/66-bilibop.rules
#
# Do not edit this file, it will be overwritten on updates. Instead,
# you can run /usr/share/bilibop/bilibop_rules_generator to create a
# (pre)customized sample /etc/udev/rules.d/66-bilibop.rules, and modify
# it if necessary.

# Process only on some block devices:
SUBSYSTEM!="block", GOTO="bilibop_end"
ACTION!="add|change", GOTO="bilibop_end"
KERNEL=="dm-?*|loop?*", GOTO="bilibop_virtual_block"
KERNEL!="sd?*|mmcblk?*|mspblk?*", GOTO="bilibop_end"

# For the resulting block devices, skip all that is not USB, FireWire or Flash
# Memory cards, and test if the device is hosted by the same disk than the root
# filesystem. If yes, fix its group to 'disk' (this is mandatory), add a tag,
# go to a xxx label to continue...
SUBSYSTEMS=="usb|firewire|memstick|mmc", \
	PROGRAM=="bilibop_disk --test %r/%k", \
	GROUP:="disk", \
	TAG+="BILIBOP", \
	GOTO="bilibop_physical_block"

# Tag internal physical block devices (disks and partitions)
SUBSYSTEMS=="usb|firewire", GOTO="bilibop_end"
KERNEL=="sd?*", TAG+="INSIDEV"

GOTO="bilibop_end"
LABEL="bilibop_physical_block"

# The partitions - add an environment variable:
ATTR{partition}=="?*", \
	ENV{BILIBOP_PARTITION}="%r/%k", \
	GOTO="bilibop_subdevice"

# The disk - add a symlink and an environment variable:
ATTR{removable}=="?*", \
	PROGRAM=="bilibop_disk --disk %r/%k", \
	SYMLINK+="%c", \
	ENV{BILIBOP_DISK}="%r/%k"

# The disk - say Udisks to not detach the drive from its bus,
# and set it as 'system internal':
ATTR{removable}=="?*", \
	TEST=="/lib/udev/rules.d/80-udisks.rules", \
	ENV{ID_DRIVE_DETACHABLE}:="0", \
	ENV{UDISKS_SYSTEM_INTERNAL}:="1"

# The disk - do the same for Udisks 2.x:
ATTR{removable}=="?*", \
	TEST=="/lib/udev/rules.d/80-udisks2.rules", \
	ENV{UDISKS_CAN_POWER_OFF}:="0", \
	ENV{UDISKS_SYSTEM}:="1"

# Nothing else to do with the disk node, go away:
ATTR{removable}=="?*", \
	GOTO="bilibop_end"

# Now process on loopback and mapped devices. If they are hosted by the same
# disk than the root filesystem, add their parent partition's name to the
# udev database:
LABEL="bilibop_virtual_block"

# Process only on associated loop devices
KERNEL=="loop?*", \
	TEST=="loop/backing_file", \
	PROGRAM=="bilibop_disk --test %r/%k", \
	PROGRAM=="bilibop_disk --part %r/%k", \
	ENV{BILIBOP_UNDERLYING_PARTITION}="%c", \
	TAG+="BILIBOP", \
	GOTO="bilibop_subdevice"

# When a dm device has been added from the initrd environment (and this is the
# case for bilibop's encrypted LVM), the udev instance launched by init in the
# system environment triggers a spurious 'add' event, leading udev to be out
# of sync (see 55-dm.rules): it can happen that a dm device has no symlink at
# all in the udev database, and symlinks existing in /dev are no more managed
# by udev. Then 'update-grub' can fail; and bilibop's physical_volumes_filter
# script needs at least one symlink, so we restore it here.
KERNEL=="dm-?*", \
	PROGRAM=="bilibop_disk --test %r/%k", \
	PROGRAM=="bilibop_disk --part %r/%k", \
	ENV{BILIBOP_UNDERLYING_PARTITION}="%c", \
	SYMLINK+="mapper/$attr{dm/name}", \
	TAG+="BILIBOP", \
	GOTO="bilibop_subdevice"

# Now we will process on the partitions and virtual block devices that have
# been tagged 'BILIBOP'...
GOTO="bilibop_end"
LABEL="bilibop_subdevice"

# Add two other symlinks: one targetting the root filesystem (root),
# and the other targetting its underlying partition (part):
PROGRAM=="bilibop_disk --root %r/%k", SYMLINK+="%c"

# Do not perform direct access (with blkid -p) to suspended dm devices.
ENV{DM_SUSPENDED}=="1", GOTO="bilibop_dm_end"

# Due to the bilibop configuration file, based on ID_FS_* udev variables, we
# need additional information here, and we want to be sure this information
# is available for the next rules (udisks). Additionnaly, drivemap(1) and
# lsbilibop(8) commands can need to query ID_FS_* values, even if udisks is
# not installed.
ENV{ID_FS_USAGE}=="", IMPORT{program}="/sbin/blkid -o udev -p %r/%k"

# If the device is a Logical Volume, we *restore* /dev/vg_name/lv_name symlink
# in udev database (see above). This overrides the *-dm.rules and *-lvm.rules.
KERNEL!="dm-?*", GOTO="bilibop_dm_end"

ATTR{dm/uuid}=="LVM-?*", ENV{DM_LV_NAME}=="", \
	IMPORT{program}="/sbin/dmsetup splitname --nameprefixes --noheadings --rows $attr{dm/name}"

ENV{DM_LV_NAME}=="?*", ENV{DM_VG_NAME}=="?*", ENV{DM_LV_LAYER}=="", \
	SYMLINK+="$env{DM_VG_NAME}/$env{DM_LV_NAME}"

LABEL="bilibop_dm_end"

# The following rules are for the desktop environment; they make sense only if
# udisks and/or udisks2 are installed:
TEST!="/lib/udev/rules.d/80-udisks.rules", GOTO="bilibop_udisks_end"
PROGRAM=="bilibop_disk --lock %r/%k", ENV{UDISKS_SYSTEM_INTERNAL}:="1"
PROGRAM=="bilibop_disk --hide %r/%k", ENV{UDISKS_PRESENTATION_HIDE}:="1", GOTO="bilibop_udisks_end"
PROGRAM=="bilibop_disk --icon %r/%k", ENV{UDISKS_PRESENTATION_ICON_NAME}:="%c"
PROGRAM=="bilibop_disk --name %r/%k", ENV{UDISKS_PRESENTATION_NAME}:="%c"
LABEL="bilibop_udisks_end"

TEST!="/lib/udev/rules.d/80-udisks2.rules", GOTO="bilibop_udisks2_end"
PROGRAM=="bilibop_disk --lock %r/%k", ENV{UDISKS_SYSTEM}:="1"
PROGRAM=="bilibop_disk --hide %r/%k", ENV{UDISKS_IGNORE}:="1", GOTO="bilibop_udisks2_end"
PROGRAM=="bilibop_disk --icon %r/%k", ENV{UDISKS_ICON_NAME}:="%c"
PROGRAM=="bilibop_disk --name %r/%k", ENV{UDISKS_NAME}:="%c"
LABEL="bilibop_udisks2_end"

LABEL="bilibop_end"
